import express from 'express';
import cors from 'cors';
import fs from 'fs';
import path from 'path';
import moment from 'moment';

const app = express();
const PORT = process.env.PORT || 22222;

app.use(cors());
app.use(express.json());

const VAULT_PATH = process.env.OBSIDIAN_VAULT_PATH || path.join(process.env.HOME || '/tmp', 'vault');

function getMarkdownFiles(dir: string): string[] {
  if (!fs.existsSync(dir)) {
    console.log(`‚ùå Vault path does not exist: ${dir}`);
    return [];
  }
  
  const files = fs.readdirSync(dir);
  const mdFiles: string[] = [];
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      mdFiles.push(...getMarkdownFiles(filePath));
    } else if (file.endsWith('.md')) {
      mdFiles.push(filePath);
    }
  }
  
  return mdFiles;
}

interface DueDate {
  dueDate: string;
  assignment: string;
  file: string;
  completed: boolean;
  formattedDate: string;
}

function parseDueDates(content: string, filePath: string, includeCompleted = false): DueDate[] {
  const dueDates: DueDate[] = [];
  
  const regex = /# Due Dates([\s\S]*?)(?=\n#|$)/;
  const match = content.match(regex);
  
  if (match) {
    const tableData = match[1].trim();
    const lines = tableData.split("\n").slice(1);
    
    for (const line of lines) {
      const columns = line
        .split("|")
        .map((c) => c.trim())
        .filter((c) => c);
      
      if (columns.length >= 2) {
        let [dueDate, assignment] = columns;
        
        // Check if assignment is completed (has ‚úÖ)
        const isCompleted = assignment?.match(/‚úÖ/) !== null;
        
        // Skip completed items unless includeCompleted is true
        if (isCompleted && !includeCompleted) {
          continue;
        }
        
        if (!Date.parse(dueDate)) {
          continue;
        }
        
        assignment = assignment?.match(/[A-Z]{3}-[0-9]{3}/)
          ? assignment
          : `#${path.basename(filePath, '.md')} - ${assignment}`;
        
        const dueDateMoment = moment(dueDate);
        const now = moment();
        
        if (dueDateMoment.isBefore(now.subtract(1, 'month'))) {
          continue;
        }
        
        let formattedDate: string;
        if (dueDateMoment.isAfter(now.subtract(1, 'w'))) {
          formattedDate = `<span class="due one_week">${dueDateMoment.format("YYYY-MM-DD ddd")}</span>`;
        } else if (dueDateMoment.isAfter(now.subtract(2, 'w'))) {
          formattedDate = `<span class="due two_weeks">${dueDateMoment.format("YYYY-MM-DD ddd")}</span>`;
        } else {
          formattedDate = dueDateMoment.format("YYYY-MM-DD ddd");
        }
        
        dueDates.push({
          dueDate,
          assignment,
          file: filePath,
          completed: isCompleted,
          formattedDate
        });
      }
    }
  }
  
  return dueDates;
}

app.get('/due-dates', (req, res) => {
  try {
    console.log('üîç Processing due-dates request...');
    
    const allFiles = getMarkdownFiles(VAULT_PATH);
    let allDueDates: DueDate[] = [];
    
    console.log(`üìÅ Found ${allFiles.length} markdown files to process`);
    // Parse query parameters
    const includeCompleted = req.query.includeCompleted === "true" || req.query.includeCompleted === "1";
    for (const file of allFiles) {
      try {
        const content = fs.readFileSync(file, 'utf-8');
        const relativePath = path.relative(VAULT_PATH, file);
        console.log(`üìÑ Processing: ${relativePath}`);
        
        const dueDates = parseDueDates(content, file, includeCompleted);
        if (dueDates.length > 0) {
          console.log(`‚úÖ Found ${dueDates.length} due dates in ${relativePath}`);
          allDueDates.push(...dueDates);
        }
      } catch (fileError) {
        console.error(`‚ùå Error reading file ${file}:`, fileError);
      }
    }
    
    console.log(`üìã Total due dates found: ${allDueDates.length}`);
    
    // Parse query parameters
    const includeCompleted = req.query.includeCompleted === 'true' || req.query.includeCompleted === '1';
    
    console.log(`üìã includeCompleted: ${includeCompleted}`);
    
    allDueDates.sort((a, b) => moment(a.dueDate).valueOf() - moment(b.dueDate).valueOf());
    
    // Apply date filtering with proper logic
    const { startDate, endDate } = req.query;
    
    if (startDate) {
      console.log(`üìÖ Applying startDate filter: ${startDate}`);
      const start = moment(startDate as string).startOf('day');
      allDueDates = allDueDates.filter(dd => {
        const ddMoment = moment(dd.dueDate);
        return ddMoment.isSameOrAfter(start, 'day');
      });
    }
    
    if (endDate) {
      console.log(`üìÖ Applying endDate filter: ${endDate}`);
      const end = moment(endDate as string).endOf('day');
      allDueDates = allDueDates.filter(dd => {
        const ddMoment = moment(dd.dueDate);
        return ddMoment.isSameOrBefore(end, 'day');
      });
    }
    
    res.json({
      success: true,
      count: allDueDates.length,
      dueDates: allDueDates,
      source: "obsidian-todos-api",
      timestamp: new Date().toISOString(),
      filters: {
        includeCompleted,
        startDate: startDate || null,
        endDate: endDate || null
      }
    });
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Error fetching due dates:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch due dates',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

interface Todo {
  id: string;
  text: string;
  completed: boolean;
  file: string;
  line: number;
  status?: string;  // Added status field for custom todo markers
}

function parseTodos(content: string, filePath: string): Todo[] {
  const todos: Todo[] = [];
  const lines = content.split('\n');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Enhanced regex to capture any character in brackets: - [x], - [!], - [?], etc.
    const todoMatch = line.match(/^-\s*\[(.)\]\s*(.+)$/);
    
    if (todoMatch) {
      const status = todoMatch[1];  // The character in brackets: x, X, !, ?, etc.
      const completed = status.toLowerCase() === 'x';  // Only 'x' or 'X' means completed
      const text = todoMatch[2].trim();
      
      todos.push({
        id: `${filePath}:${i}`,
        text,
        completed,
        file: path.relative(VAULT_PATH, filePath),
        line: i + 1,
        status: status  // Store the actual status character
      });
    }
  }
  
  return todos;
}

app.get('/todos', (req, res) => {
  try {
    console.log("üîç Processing todos request...");
    console.log(`üìä Query params:`, req.query);
    const allFiles = getMarkdownFiles(VAULT_PATH);
    let allTodos: Todo[] = [];

    for (const file of allFiles) {
      const content = fs.readFileSync(file, "utf-8");
      const todos = parseTodos(content, file);
      allTodos.push(...todos);
    }

    console.log(`üìã Total todos found before filtering: ${allTodos.length}`);

    // Apply filtering based on query parameters
    const { completed, status, search, file: fileFilter } = req.query;

    if (completed !== undefined) {
      const isCompleted = completed === "true" || completed === "1";
      console.log(`üìã Filtering by completed: ${isCompleted}`);
      allTodos = allTodos.filter(todo => todo.completed === isCompleted);
    }

    if (status) {
      console.log(`üìã Filtering by status: ${status}`);
      allTodos = allTodos.filter(todo => todo.status === status);
    }

    if (search) {
      console.log(`üîç Filtering by search: ${search}`);
      const searchLower = (search as string).toLowerCase();
      allTodos = allTodos.filter(todo =>
        todo.text.toLowerCase().includes(searchLower)
      );
    res.json({
      success: true,
      count: allTodos.length,
      todos: allTodos,
      source: "obsidian-todos-api",
      timestamp: new Date().toISOString(),
      filters: {
        completed: completed || null,
        status: status || null,
    console.error("‚ùå Error fetching todos:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch todos",
      message: error instanceof Error ? error.message : "Unknown error"
    });

    console.log(`üìä Returning ${allTodos.length} todos after filtering`);
            text,
            completed,
            file: path.relative(VAULT_PATH, file),
            line: i + 1
          });
        }
      }
    }
    
    res.json({
      success: true,
      count: allTodos.length,
      todos: allTodos
    });
  } catch (error) {
    console.error('Error fetching todos:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch todos'
    });
  }
});

app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Obsidian Todos API Server is running',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

app.listen(PORT, () => {
  console.log(`üöÄ Obsidian Todos API Server running on port ${PORT}`);
  console.log(`üìÅ Vault path: ${VAULT_PATH}`);
  console.log(`üìã Endpoints:`);
  console.log(`   GET  /due-dates - List all due dates`);
  console.log(`   GET  /todos     - List all todos`);
  console.log(`   GET  /health    - Health check`);
  console.log('');
  console.log('‚úÖ The list_due_dates endpoint is now available!');
});

export default app;
